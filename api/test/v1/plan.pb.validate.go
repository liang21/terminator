// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/test/v1/plan.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on TestPlan with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestPlan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestPlan with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestPlanMultiError, or nil
// if none found.
func (m *TestPlan) ValidateAll() error {
	return m.validate(true)
}

func (m *TestPlan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ProjectId

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for Stage

	// no validation rules for Description

	// no validation rules for ReviewTotal

	// no validation rules for ReviewPassRule

	if all {
		switch v := interface{}(m.GetPlannedStartAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestPlanValidationError{
					field:  "PlannedStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestPlanValidationError{
					field:  "PlannedStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlannedStartAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestPlanValidationError{
				field:  "PlannedStartAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlannedEndAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestPlanValidationError{
					field:  "PlannedEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestPlanValidationError{
					field:  "PlannedEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlannedEndAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestPlanValidationError{
				field:  "PlannedEndAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActualStartAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestPlanValidationError{
					field:  "ActualStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestPlanValidationError{
					field:  "ActualStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualStartAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestPlanValidationError{
				field:  "ActualStartAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActualEndAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestPlanValidationError{
					field:  "ActualEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestPlanValidationError{
					field:  "ActualEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualEndAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestPlanValidationError{
				field:  "ActualEndAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TestPlanMultiError(errors)
	}

	return nil
}

// TestPlanMultiError is an error wrapping multiple validation errors returned
// by TestPlan.ValidateAll() if the designated constraints aren't met.
type TestPlanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestPlanMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestPlanMultiError) AllErrors() []error { return m }

// TestPlanValidationError is the validation error returned by
// TestPlan.Validate if the designated constraints aren't met.
type TestPlanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestPlanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestPlanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestPlanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestPlanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestPlanValidationError) ErrorName() string { return "TestPlanValidationError" }

// Error satisfies the builtin error interface
func (e TestPlanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestPlan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestPlanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestPlanValidationError{}

// Validate checks the field values on CreateTestPlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTestPlanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTestPlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTestPlanRequestMultiError, or nil if none found.
func (m *CreateTestPlanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTestPlanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProjectId() <= 0 {
		err := CreateTestPlanRequestValidationError{
			field:  "ProjectId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 50 {
		err := CreateTestPlanRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Status

	// no validation rules for Stage

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetPlannedStartAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTestPlanRequestValidationError{
					field:  "PlannedStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTestPlanRequestValidationError{
					field:  "PlannedStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlannedStartAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTestPlanRequestValidationError{
				field:  "PlannedStartAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlannedEndAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTestPlanRequestValidationError{
					field:  "PlannedEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTestPlanRequestValidationError{
					field:  "PlannedEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlannedEndAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTestPlanRequestValidationError{
				field:  "PlannedEndAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActualStartAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTestPlanRequestValidationError{
					field:  "ActualStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTestPlanRequestValidationError{
					field:  "ActualStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualStartAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTestPlanRequestValidationError{
				field:  "ActualStartAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActualEndAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTestPlanRequestValidationError{
					field:  "ActualEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTestPlanRequestValidationError{
					field:  "ActualEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualEndAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTestPlanRequestValidationError{
				field:  "ActualEndAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTestPlanRequestMultiError(errors)
	}

	return nil
}

// CreateTestPlanRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTestPlanRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTestPlanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTestPlanRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTestPlanRequestMultiError) AllErrors() []error { return m }

// CreateTestPlanRequestValidationError is the validation error returned by
// CreateTestPlanRequest.Validate if the designated constraints aren't met.
type CreateTestPlanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTestPlanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTestPlanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTestPlanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTestPlanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTestPlanRequestValidationError) ErrorName() string {
	return "CreateTestPlanRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTestPlanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTestPlanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTestPlanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTestPlanRequestValidationError{}

// Validate checks the field values on CreateTestPlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTestPlanReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTestPlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTestPlanReplyMultiError, or nil if none found.
func (m *CreateTestPlanReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTestPlanReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestPlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTestPlanReplyValidationError{
					field:  "TestPlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTestPlanReplyValidationError{
					field:  "TestPlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestPlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTestPlanReplyValidationError{
				field:  "TestPlan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTestPlanReplyMultiError(errors)
	}

	return nil
}

// CreateTestPlanReplyMultiError is an error wrapping multiple validation
// errors returned by CreateTestPlanReply.ValidateAll() if the designated
// constraints aren't met.
type CreateTestPlanReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTestPlanReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTestPlanReplyMultiError) AllErrors() []error { return m }

// CreateTestPlanReplyValidationError is the validation error returned by
// CreateTestPlanReply.Validate if the designated constraints aren't met.
type CreateTestPlanReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTestPlanReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTestPlanReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTestPlanReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTestPlanReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTestPlanReplyValidationError) ErrorName() string {
	return "CreateTestPlanReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTestPlanReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTestPlanReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTestPlanReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTestPlanReplyValidationError{}

// Validate checks the field values on UpdateTestPlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTestPlanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTestPlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTestPlanRequestMultiError, or nil if none found.
func (m *UpdateTestPlanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTestPlanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateTestPlanRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetProjectId() <= 0 {
		err := UpdateTestPlanRequestValidationError{
			field:  "ProjectId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 50 {
		err := UpdateTestPlanRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Status

	// no validation rules for Stage

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetPlannedStartAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTestPlanRequestValidationError{
					field:  "PlannedStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTestPlanRequestValidationError{
					field:  "PlannedStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlannedStartAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTestPlanRequestValidationError{
				field:  "PlannedStartAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlannedEndAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTestPlanRequestValidationError{
					field:  "PlannedEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTestPlanRequestValidationError{
					field:  "PlannedEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlannedEndAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTestPlanRequestValidationError{
				field:  "PlannedEndAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActualStartAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTestPlanRequestValidationError{
					field:  "ActualStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTestPlanRequestValidationError{
					field:  "ActualStartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualStartAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTestPlanRequestValidationError{
				field:  "ActualStartAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActualEndAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTestPlanRequestValidationError{
					field:  "ActualEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTestPlanRequestValidationError{
					field:  "ActualEndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualEndAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTestPlanRequestValidationError{
				field:  "ActualEndAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTestPlanRequestMultiError(errors)
	}

	return nil
}

// UpdateTestPlanRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateTestPlanRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateTestPlanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTestPlanRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTestPlanRequestMultiError) AllErrors() []error { return m }

// UpdateTestPlanRequestValidationError is the validation error returned by
// UpdateTestPlanRequest.Validate if the designated constraints aren't met.
type UpdateTestPlanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTestPlanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTestPlanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTestPlanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTestPlanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTestPlanRequestValidationError) ErrorName() string {
	return "UpdateTestPlanRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTestPlanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTestPlanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTestPlanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTestPlanRequestValidationError{}

// Validate checks the field values on UpdateTestPlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTestPlanReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTestPlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTestPlanReplyMultiError, or nil if none found.
func (m *UpdateTestPlanReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTestPlanReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestPlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTestPlanReplyValidationError{
					field:  "TestPlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTestPlanReplyValidationError{
					field:  "TestPlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestPlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTestPlanReplyValidationError{
				field:  "TestPlan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTestPlanReplyMultiError(errors)
	}

	return nil
}

// UpdateTestPlanReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateTestPlanReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateTestPlanReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTestPlanReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTestPlanReplyMultiError) AllErrors() []error { return m }

// UpdateTestPlanReplyValidationError is the validation error returned by
// UpdateTestPlanReply.Validate if the designated constraints aren't met.
type UpdateTestPlanReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTestPlanReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTestPlanReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTestPlanReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTestPlanReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTestPlanReplyValidationError) ErrorName() string {
	return "UpdateTestPlanReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTestPlanReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTestPlanReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTestPlanReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTestPlanReplyValidationError{}

// Validate checks the field values on DeleteTestPlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTestPlanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTestPlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTestPlanRequestMultiError, or nil if none found.
func (m *DeleteTestPlanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTestPlanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteTestPlanRequestMultiError(errors)
	}

	return nil
}

// DeleteTestPlanRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteTestPlanRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteTestPlanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTestPlanRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTestPlanRequestMultiError) AllErrors() []error { return m }

// DeleteTestPlanRequestValidationError is the validation error returned by
// DeleteTestPlanRequest.Validate if the designated constraints aren't met.
type DeleteTestPlanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTestPlanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTestPlanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTestPlanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTestPlanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTestPlanRequestValidationError) ErrorName() string {
	return "DeleteTestPlanRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTestPlanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTestPlanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTestPlanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTestPlanRequestValidationError{}

// Validate checks the field values on DeleteTestPlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTestPlanReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTestPlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTestPlanReplyMultiError, or nil if none found.
func (m *DeleteTestPlanReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTestPlanReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteTestPlanReplyMultiError(errors)
	}

	return nil
}

// DeleteTestPlanReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteTestPlanReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteTestPlanReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTestPlanReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTestPlanReplyMultiError) AllErrors() []error { return m }

// DeleteTestPlanReplyValidationError is the validation error returned by
// DeleteTestPlanReply.Validate if the designated constraints aren't met.
type DeleteTestPlanReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTestPlanReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTestPlanReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTestPlanReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTestPlanReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTestPlanReplyValidationError) ErrorName() string {
	return "DeleteTestPlanReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTestPlanReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTestPlanReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTestPlanReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTestPlanReplyValidationError{}

// Validate checks the field values on GetTestPlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTestPlanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTestPlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTestPlanRequestMultiError, or nil if none found.
func (m *GetTestPlanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTestPlanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetTestPlanRequestMultiError(errors)
	}

	return nil
}

// GetTestPlanRequestMultiError is an error wrapping multiple validation errors
// returned by GetTestPlanRequest.ValidateAll() if the designated constraints
// aren't met.
type GetTestPlanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTestPlanRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTestPlanRequestMultiError) AllErrors() []error { return m }

// GetTestPlanRequestValidationError is the validation error returned by
// GetTestPlanRequest.Validate if the designated constraints aren't met.
type GetTestPlanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTestPlanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTestPlanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTestPlanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTestPlanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTestPlanRequestValidationError) ErrorName() string {
	return "GetTestPlanRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTestPlanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTestPlanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTestPlanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTestPlanRequestValidationError{}

// Validate checks the field values on GetTestPlanReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetTestPlanReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTestPlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTestPlanReplyMultiError, or nil if none found.
func (m *GetTestPlanReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTestPlanReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestPlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTestPlanReplyValidationError{
					field:  "TestPlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTestPlanReplyValidationError{
					field:  "TestPlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestPlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTestPlanReplyValidationError{
				field:  "TestPlan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTestPlanReplyMultiError(errors)
	}

	return nil
}

// GetTestPlanReplyMultiError is an error wrapping multiple validation errors
// returned by GetTestPlanReply.ValidateAll() if the designated constraints
// aren't met.
type GetTestPlanReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTestPlanReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTestPlanReplyMultiError) AllErrors() []error { return m }

// GetTestPlanReplyValidationError is the validation error returned by
// GetTestPlanReply.Validate if the designated constraints aren't met.
type GetTestPlanReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTestPlanReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTestPlanReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTestPlanReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTestPlanReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTestPlanReplyValidationError) ErrorName() string { return "GetTestPlanReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetTestPlanReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTestPlanReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTestPlanReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTestPlanReplyValidationError{}

// Validate checks the field values on ListTestPlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTestPlanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTestPlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTestPlanRequestMultiError, or nil if none found.
func (m *ListTestPlanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTestPlanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Parent

	// no validation rules for PageSize

	// no validation rules for PageToken

	if len(errors) > 0 {
		return ListTestPlanRequestMultiError(errors)
	}

	return nil
}

// ListTestPlanRequestMultiError is an error wrapping multiple validation
// errors returned by ListTestPlanRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTestPlanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTestPlanRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTestPlanRequestMultiError) AllErrors() []error { return m }

// ListTestPlanRequestValidationError is the validation error returned by
// ListTestPlanRequest.Validate if the designated constraints aren't met.
type ListTestPlanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTestPlanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTestPlanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTestPlanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTestPlanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTestPlanRequestValidationError) ErrorName() string {
	return "ListTestPlanRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTestPlanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTestPlanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTestPlanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTestPlanRequestValidationError{}

// Validate checks the field values on ListTestPlanReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListTestPlanReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTestPlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTestPlanReplyMultiError, or nil if none found.
func (m *ListTestPlanReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTestPlanReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTestPlanReplyValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTestPlanReplyValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTestPlanReplyValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTestPlanReplyMultiError(errors)
	}

	return nil
}

// ListTestPlanReplyMultiError is an error wrapping multiple validation errors
// returned by ListTestPlanReply.ValidateAll() if the designated constraints
// aren't met.
type ListTestPlanReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTestPlanReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTestPlanReplyMultiError) AllErrors() []error { return m }

// ListTestPlanReplyValidationError is the validation error returned by
// ListTestPlanReply.Validate if the designated constraints aren't met.
type ListTestPlanReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTestPlanReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTestPlanReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTestPlanReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTestPlanReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTestPlanReplyValidationError) ErrorName() string {
	return "ListTestPlanReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListTestPlanReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTestPlanReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTestPlanReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTestPlanReplyValidationError{}

// Validate checks the field values on TestPlanCase with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestPlanCase) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestPlanCase with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestPlanCaseMultiError, or
// nil if none found.
func (m *TestPlanCase) ValidateAll() error {
	return m.validate(true)
}

func (m *TestPlanCase) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for PlanId

	// no validation rules for CaseId

	// no validation rules for Status

	// no validation rules for Result

	if len(errors) > 0 {
		return TestPlanCaseMultiError(errors)
	}

	return nil
}

// TestPlanCaseMultiError is an error wrapping multiple validation errors
// returned by TestPlanCase.ValidateAll() if the designated constraints aren't met.
type TestPlanCaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestPlanCaseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestPlanCaseMultiError) AllErrors() []error { return m }

// TestPlanCaseValidationError is the validation error returned by
// TestPlanCase.Validate if the designated constraints aren't met.
type TestPlanCaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestPlanCaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestPlanCaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestPlanCaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestPlanCaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestPlanCaseValidationError) ErrorName() string { return "TestPlanCaseValidationError" }

// Error satisfies the builtin error interface
func (e TestPlanCaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestPlanCase.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestPlanCaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestPlanCaseValidationError{}

// Validate checks the field values on CreateTestPlanCaseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTestPlanCaseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTestPlanCaseRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTestPlanCaseRequestMultiError, or nil if none found.
func (m *CreateTestPlanCaseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTestPlanCaseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlanId

	// no validation rules for CaseId

	// no validation rules for Status

	// no validation rules for Result

	if len(errors) > 0 {
		return CreateTestPlanCaseRequestMultiError(errors)
	}

	return nil
}

// CreateTestPlanCaseRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTestPlanCaseRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateTestPlanCaseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTestPlanCaseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTestPlanCaseRequestMultiError) AllErrors() []error { return m }

// CreateTestPlanCaseRequestValidationError is the validation error returned by
// CreateTestPlanCaseRequest.Validate if the designated constraints aren't met.
type CreateTestPlanCaseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTestPlanCaseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTestPlanCaseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTestPlanCaseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTestPlanCaseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTestPlanCaseRequestValidationError) ErrorName() string {
	return "CreateTestPlanCaseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTestPlanCaseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTestPlanCaseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTestPlanCaseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTestPlanCaseRequestValidationError{}

// Validate checks the field values on CreateTestPlanCaseReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTestPlanCaseReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTestPlanCaseReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTestPlanCaseReplyMultiError, or nil if none found.
func (m *CreateTestPlanCaseReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTestPlanCaseReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestPlanCase()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTestPlanCaseReplyValidationError{
					field:  "TestPlanCase",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTestPlanCaseReplyValidationError{
					field:  "TestPlanCase",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestPlanCase()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTestPlanCaseReplyValidationError{
				field:  "TestPlanCase",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTestPlanCaseReplyMultiError(errors)
	}

	return nil
}

// CreateTestPlanCaseReplyMultiError is an error wrapping multiple validation
// errors returned by CreateTestPlanCaseReply.ValidateAll() if the designated
// constraints aren't met.
type CreateTestPlanCaseReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTestPlanCaseReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTestPlanCaseReplyMultiError) AllErrors() []error { return m }

// CreateTestPlanCaseReplyValidationError is the validation error returned by
// CreateTestPlanCaseReply.Validate if the designated constraints aren't met.
type CreateTestPlanCaseReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTestPlanCaseReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTestPlanCaseReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTestPlanCaseReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTestPlanCaseReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTestPlanCaseReplyValidationError) ErrorName() string {
	return "CreateTestPlanCaseReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTestPlanCaseReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTestPlanCaseReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTestPlanCaseReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTestPlanCaseReplyValidationError{}

// Validate checks the field values on UpdateTestPlanCaseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTestPlanCaseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTestPlanCaseRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTestPlanCaseRequestMultiError, or nil if none found.
func (m *UpdateTestPlanCaseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTestPlanCaseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateTestPlanCaseRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PlanId

	// no validation rules for CaseId

	// no validation rules for Status

	// no validation rules for Result

	if len(errors) > 0 {
		return UpdateTestPlanCaseRequestMultiError(errors)
	}

	return nil
}

// UpdateTestPlanCaseRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateTestPlanCaseRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateTestPlanCaseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTestPlanCaseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTestPlanCaseRequestMultiError) AllErrors() []error { return m }

// UpdateTestPlanCaseRequestValidationError is the validation error returned by
// UpdateTestPlanCaseRequest.Validate if the designated constraints aren't met.
type UpdateTestPlanCaseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTestPlanCaseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTestPlanCaseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTestPlanCaseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTestPlanCaseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTestPlanCaseRequestValidationError) ErrorName() string {
	return "UpdateTestPlanCaseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTestPlanCaseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTestPlanCaseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTestPlanCaseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTestPlanCaseRequestValidationError{}

// Validate checks the field values on UpdateTestPlanCaseReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTestPlanCaseReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTestPlanCaseReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTestPlanCaseReplyMultiError, or nil if none found.
func (m *UpdateTestPlanCaseReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTestPlanCaseReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestPlanCase()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTestPlanCaseReplyValidationError{
					field:  "TestPlanCase",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTestPlanCaseReplyValidationError{
					field:  "TestPlanCase",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestPlanCase()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTestPlanCaseReplyValidationError{
				field:  "TestPlanCase",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTestPlanCaseReplyMultiError(errors)
	}

	return nil
}

// UpdateTestPlanCaseReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateTestPlanCaseReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateTestPlanCaseReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTestPlanCaseReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTestPlanCaseReplyMultiError) AllErrors() []error { return m }

// UpdateTestPlanCaseReplyValidationError is the validation error returned by
// UpdateTestPlanCaseReply.Validate if the designated constraints aren't met.
type UpdateTestPlanCaseReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTestPlanCaseReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTestPlanCaseReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTestPlanCaseReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTestPlanCaseReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTestPlanCaseReplyValidationError) ErrorName() string {
	return "UpdateTestPlanCaseReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTestPlanCaseReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTestPlanCaseReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTestPlanCaseReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTestPlanCaseReplyValidationError{}

// Validate checks the field values on DeleteTestPlanCaseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTestPlanCaseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTestPlanCaseRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTestPlanCaseRequestMultiError, or nil if none found.
func (m *DeleteTestPlanCaseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTestPlanCaseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteTestPlanCaseRequestMultiError(errors)
	}

	return nil
}

// DeleteTestPlanCaseRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteTestPlanCaseRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteTestPlanCaseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTestPlanCaseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTestPlanCaseRequestMultiError) AllErrors() []error { return m }

// DeleteTestPlanCaseRequestValidationError is the validation error returned by
// DeleteTestPlanCaseRequest.Validate if the designated constraints aren't met.
type DeleteTestPlanCaseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTestPlanCaseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTestPlanCaseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTestPlanCaseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTestPlanCaseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTestPlanCaseRequestValidationError) ErrorName() string {
	return "DeleteTestPlanCaseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTestPlanCaseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTestPlanCaseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTestPlanCaseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTestPlanCaseRequestValidationError{}

// Validate checks the field values on DeleteTestPlanCaseReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTestPlanCaseReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTestPlanCaseReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTestPlanCaseReplyMultiError, or nil if none found.
func (m *DeleteTestPlanCaseReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTestPlanCaseReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteTestPlanCaseReplyMultiError(errors)
	}

	return nil
}

// DeleteTestPlanCaseReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteTestPlanCaseReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteTestPlanCaseReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTestPlanCaseReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTestPlanCaseReplyMultiError) AllErrors() []error { return m }

// DeleteTestPlanCaseReplyValidationError is the validation error returned by
// DeleteTestPlanCaseReply.Validate if the designated constraints aren't met.
type DeleteTestPlanCaseReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTestPlanCaseReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTestPlanCaseReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTestPlanCaseReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTestPlanCaseReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTestPlanCaseReplyValidationError) ErrorName() string {
	return "DeleteTestPlanCaseReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTestPlanCaseReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTestPlanCaseReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTestPlanCaseReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTestPlanCaseReplyValidationError{}

// Validate checks the field values on GetTestPlanCaseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTestPlanCaseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTestPlanCaseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTestPlanCaseRequestMultiError, or nil if none found.
func (m *GetTestPlanCaseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTestPlanCaseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetTestPlanCaseRequestMultiError(errors)
	}

	return nil
}

// GetTestPlanCaseRequestMultiError is an error wrapping multiple validation
// errors returned by GetTestPlanCaseRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTestPlanCaseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTestPlanCaseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTestPlanCaseRequestMultiError) AllErrors() []error { return m }

// GetTestPlanCaseRequestValidationError is the validation error returned by
// GetTestPlanCaseRequest.Validate if the designated constraints aren't met.
type GetTestPlanCaseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTestPlanCaseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTestPlanCaseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTestPlanCaseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTestPlanCaseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTestPlanCaseRequestValidationError) ErrorName() string {
	return "GetTestPlanCaseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTestPlanCaseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTestPlanCaseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTestPlanCaseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTestPlanCaseRequestValidationError{}

// Validate checks the field values on GetTestPlanCaseReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTestPlanCaseReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTestPlanCaseReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTestPlanCaseReplyMultiError, or nil if none found.
func (m *GetTestPlanCaseReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTestPlanCaseReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestPlanCase()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTestPlanCaseReplyValidationError{
					field:  "TestPlanCase",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTestPlanCaseReplyValidationError{
					field:  "TestPlanCase",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestPlanCase()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTestPlanCaseReplyValidationError{
				field:  "TestPlanCase",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTestPlanCaseReplyMultiError(errors)
	}

	return nil
}

// GetTestPlanCaseReplyMultiError is an error wrapping multiple validation
// errors returned by GetTestPlanCaseReply.ValidateAll() if the designated
// constraints aren't met.
type GetTestPlanCaseReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTestPlanCaseReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTestPlanCaseReplyMultiError) AllErrors() []error { return m }

// GetTestPlanCaseReplyValidationError is the validation error returned by
// GetTestPlanCaseReply.Validate if the designated constraints aren't met.
type GetTestPlanCaseReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTestPlanCaseReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTestPlanCaseReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTestPlanCaseReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTestPlanCaseReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTestPlanCaseReplyValidationError) ErrorName() string {
	return "GetTestPlanCaseReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetTestPlanCaseReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTestPlanCaseReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTestPlanCaseReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTestPlanCaseReplyValidationError{}

// Validate checks the field values on ListTestPlanCaseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTestPlanCaseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTestPlanCaseRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTestPlanCaseRequestMultiError, or nil if none found.
func (m *ListTestPlanCaseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTestPlanCaseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Parent

	// no validation rules for PageSize

	// no validation rules for PageToken

	if len(errors) > 0 {
		return ListTestPlanCaseRequestMultiError(errors)
	}

	return nil
}

// ListTestPlanCaseRequestMultiError is an error wrapping multiple validation
// errors returned by ListTestPlanCaseRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTestPlanCaseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTestPlanCaseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTestPlanCaseRequestMultiError) AllErrors() []error { return m }

// ListTestPlanCaseRequestValidationError is the validation error returned by
// ListTestPlanCaseRequest.Validate if the designated constraints aren't met.
type ListTestPlanCaseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTestPlanCaseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTestPlanCaseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTestPlanCaseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTestPlanCaseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTestPlanCaseRequestValidationError) ErrorName() string {
	return "ListTestPlanCaseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTestPlanCaseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTestPlanCaseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTestPlanCaseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTestPlanCaseRequestValidationError{}

// Validate checks the field values on ListTestPlanCaseReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTestPlanCaseReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTestPlanCaseReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTestPlanCaseReplyMultiError, or nil if none found.
func (m *ListTestPlanCaseReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTestPlanCaseReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTestPlanCaseReplyValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTestPlanCaseReplyValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTestPlanCaseReplyValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTestPlanCaseReplyMultiError(errors)
	}

	return nil
}

// ListTestPlanCaseReplyMultiError is an error wrapping multiple validation
// errors returned by ListTestPlanCaseReply.ValidateAll() if the designated
// constraints aren't met.
type ListTestPlanCaseReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTestPlanCaseReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTestPlanCaseReplyMultiError) AllErrors() []error { return m }

// ListTestPlanCaseReplyValidationError is the validation error returned by
// ListTestPlanCaseReply.Validate if the designated constraints aren't met.
type ListTestPlanCaseReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTestPlanCaseReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTestPlanCaseReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTestPlanCaseReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTestPlanCaseReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTestPlanCaseReplyValidationError) ErrorName() string {
	return "ListTestPlanCaseReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListTestPlanCaseReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTestPlanCaseReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTestPlanCaseReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTestPlanCaseReplyValidationError{}

// Validate checks the field values on TestPlanReport with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestPlanReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestPlanReport with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestPlanReportMultiError,
// or nil if none found.
func (m *TestPlanReport) ValidateAll() error {
	return m.validate(true)
}

func (m *TestPlanReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TestPlanId

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for Success

	if len(errors) > 0 {
		return TestPlanReportMultiError(errors)
	}

	return nil
}

// TestPlanReportMultiError is an error wrapping multiple validation errors
// returned by TestPlanReport.ValidateAll() if the designated constraints
// aren't met.
type TestPlanReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestPlanReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestPlanReportMultiError) AllErrors() []error { return m }

// TestPlanReportValidationError is the validation error returned by
// TestPlanReport.Validate if the designated constraints aren't met.
type TestPlanReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestPlanReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestPlanReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestPlanReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestPlanReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestPlanReportValidationError) ErrorName() string { return "TestPlanReportValidationError" }

// Error satisfies the builtin error interface
func (e TestPlanReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestPlanReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestPlanReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestPlanReportValidationError{}

// Validate checks the field values on GetTestPlanReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTestPlanReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTestPlanReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTestPlanReportRequestMultiError, or nil if none found.
func (m *GetTestPlanReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTestPlanReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetTestPlanReportRequestMultiError(errors)
	}

	return nil
}

// GetTestPlanReportRequestMultiError is an error wrapping multiple validation
// errors returned by GetTestPlanReportRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTestPlanReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTestPlanReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTestPlanReportRequestMultiError) AllErrors() []error { return m }

// GetTestPlanReportRequestValidationError is the validation error returned by
// GetTestPlanReportRequest.Validate if the designated constraints aren't met.
type GetTestPlanReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTestPlanReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTestPlanReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTestPlanReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTestPlanReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTestPlanReportRequestValidationError) ErrorName() string {
	return "GetTestPlanReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTestPlanReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTestPlanReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTestPlanReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTestPlanReportRequestValidationError{}

// Validate checks the field values on GetTestPlanReportReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTestPlanReportReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTestPlanReportReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTestPlanReportReplyMultiError, or nil if none found.
func (m *GetTestPlanReportReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTestPlanReportReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestPlanReport()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTestPlanReportReplyValidationError{
					field:  "TestPlanReport",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTestPlanReportReplyValidationError{
					field:  "TestPlanReport",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestPlanReport()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTestPlanReportReplyValidationError{
				field:  "TestPlanReport",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTestPlanReportReplyMultiError(errors)
	}

	return nil
}

// GetTestPlanReportReplyMultiError is an error wrapping multiple validation
// errors returned by GetTestPlanReportReply.ValidateAll() if the designated
// constraints aren't met.
type GetTestPlanReportReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTestPlanReportReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTestPlanReportReplyMultiError) AllErrors() []error { return m }

// GetTestPlanReportReplyValidationError is the validation error returned by
// GetTestPlanReportReply.Validate if the designated constraints aren't met.
type GetTestPlanReportReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTestPlanReportReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTestPlanReportReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTestPlanReportReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTestPlanReportReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTestPlanReportReplyValidationError) ErrorName() string {
	return "GetTestPlanReportReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetTestPlanReportReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTestPlanReportReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTestPlanReportReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTestPlanReportReplyValidationError{}
