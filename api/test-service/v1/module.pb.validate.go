// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/test/v1/module.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on TestModule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestModule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestModuleMultiError, or
// nil if none found.
func (m *TestModule) ValidateAll() error {
	return m.validate(true)
}

func (m *TestModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ProjectId

	if len(errors) > 0 {
		return TestModuleMultiError(errors)
	}

	return nil
}

// TestModuleMultiError is an error wrapping multiple validation errors
// returned by TestModule.ValidateAll() if the designated constraints aren't met.
type TestModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestModuleMultiError) AllErrors() []error { return m }

// TestModuleValidationError is the validation error returned by
// TestModule.Validate if the designated constraints aren't met.
type TestModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestModuleValidationError) ErrorName() string { return "TestModuleValidationError" }

// Error satisfies the builtin error interface
func (e TestModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestModuleValidationError{}

// Validate checks the field values on CreateTestModuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTestModuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTestModuleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTestModuleRequestMultiError, or nil if none found.
func (m *CreateTestModuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTestModuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 50 {
		err := CreateTestModuleRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetProjectId() <= 0 {
		err := CreateTestModuleRequestValidationError{
			field:  "ProjectId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateTestModuleRequestMultiError(errors)
	}

	return nil
}

// CreateTestModuleRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTestModuleRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTestModuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTestModuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTestModuleRequestMultiError) AllErrors() []error { return m }

// CreateTestModuleRequestValidationError is the validation error returned by
// CreateTestModuleRequest.Validate if the designated constraints aren't met.
type CreateTestModuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTestModuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTestModuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTestModuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTestModuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTestModuleRequestValidationError) ErrorName() string {
	return "CreateTestModuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTestModuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTestModuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTestModuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTestModuleRequestValidationError{}

// Validate checks the field values on CreateTestModuleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTestModuleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTestModuleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTestModuleReplyMultiError, or nil if none found.
func (m *CreateTestModuleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTestModuleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTestModuleReplyValidationError{
					field:  "TestModule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTestModuleReplyValidationError{
					field:  "TestModule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTestModuleReplyValidationError{
				field:  "TestModule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTestModuleReplyMultiError(errors)
	}

	return nil
}

// CreateTestModuleReplyMultiError is an error wrapping multiple validation
// errors returned by CreateTestModuleReply.ValidateAll() if the designated
// constraints aren't met.
type CreateTestModuleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTestModuleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTestModuleReplyMultiError) AllErrors() []error { return m }

// CreateTestModuleReplyValidationError is the validation error returned by
// CreateTestModuleReply.Validate if the designated constraints aren't met.
type CreateTestModuleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTestModuleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTestModuleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTestModuleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTestModuleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTestModuleReplyValidationError) ErrorName() string {
	return "CreateTestModuleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTestModuleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTestModuleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTestModuleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTestModuleReplyValidationError{}

// Validate checks the field values on UpdateTestModuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTestModuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTestModuleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTestModuleRequestMultiError, or nil if none found.
func (m *UpdateTestModuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTestModuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateTestModuleRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 50 {
		err := UpdateTestModuleRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetProjectId() <= 0 {
		err := UpdateTestModuleRequestValidationError{
			field:  "ProjectId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateTestModuleRequestMultiError(errors)
	}

	return nil
}

// UpdateTestModuleRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateTestModuleRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateTestModuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTestModuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTestModuleRequestMultiError) AllErrors() []error { return m }

// UpdateTestModuleRequestValidationError is the validation error returned by
// UpdateTestModuleRequest.Validate if the designated constraints aren't met.
type UpdateTestModuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTestModuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTestModuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTestModuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTestModuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTestModuleRequestValidationError) ErrorName() string {
	return "UpdateTestModuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTestModuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTestModuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTestModuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTestModuleRequestValidationError{}

// Validate checks the field values on UpdateTestModuleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTestModuleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTestModuleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTestModuleReplyMultiError, or nil if none found.
func (m *UpdateTestModuleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTestModuleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTestModuleReplyValidationError{
					field:  "TestModule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTestModuleReplyValidationError{
					field:  "TestModule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTestModuleReplyValidationError{
				field:  "TestModule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTestModuleReplyMultiError(errors)
	}

	return nil
}

// UpdateTestModuleReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateTestModuleReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateTestModuleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTestModuleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTestModuleReplyMultiError) AllErrors() []error { return m }

// UpdateTestModuleReplyValidationError is the validation error returned by
// UpdateTestModuleReply.Validate if the designated constraints aren't met.
type UpdateTestModuleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTestModuleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTestModuleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTestModuleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTestModuleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTestModuleReplyValidationError) ErrorName() string {
	return "UpdateTestModuleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTestModuleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTestModuleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTestModuleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTestModuleReplyValidationError{}

// Validate checks the field values on DeleteTestModuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTestModuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTestModuleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTestModuleRequestMultiError, or nil if none found.
func (m *DeleteTestModuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTestModuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteTestModuleRequestMultiError(errors)
	}

	return nil
}

// DeleteTestModuleRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteTestModuleRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteTestModuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTestModuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTestModuleRequestMultiError) AllErrors() []error { return m }

// DeleteTestModuleRequestValidationError is the validation error returned by
// DeleteTestModuleRequest.Validate if the designated constraints aren't met.
type DeleteTestModuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTestModuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTestModuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTestModuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTestModuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTestModuleRequestValidationError) ErrorName() string {
	return "DeleteTestModuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTestModuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTestModuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTestModuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTestModuleRequestValidationError{}

// Validate checks the field values on DeleteTestModuleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTestModuleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTestModuleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTestModuleReplyMultiError, or nil if none found.
func (m *DeleteTestModuleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTestModuleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteTestModuleReplyMultiError(errors)
	}

	return nil
}

// DeleteTestModuleReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteTestModuleReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteTestModuleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTestModuleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTestModuleReplyMultiError) AllErrors() []error { return m }

// DeleteTestModuleReplyValidationError is the validation error returned by
// DeleteTestModuleReply.Validate if the designated constraints aren't met.
type DeleteTestModuleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTestModuleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTestModuleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTestModuleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTestModuleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTestModuleReplyValidationError) ErrorName() string {
	return "DeleteTestModuleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTestModuleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTestModuleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTestModuleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTestModuleReplyValidationError{}

// Validate checks the field values on GetTestModuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTestModuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTestModuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTestModuleRequestMultiError, or nil if none found.
func (m *GetTestModuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTestModuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetTestModuleRequestMultiError(errors)
	}

	return nil
}

// GetTestModuleRequestMultiError is an error wrapping multiple validation
// errors returned by GetTestModuleRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTestModuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTestModuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTestModuleRequestMultiError) AllErrors() []error { return m }

// GetTestModuleRequestValidationError is the validation error returned by
// GetTestModuleRequest.Validate if the designated constraints aren't met.
type GetTestModuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTestModuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTestModuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTestModuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTestModuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTestModuleRequestValidationError) ErrorName() string {
	return "GetTestModuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTestModuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTestModuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTestModuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTestModuleRequestValidationError{}

// Validate checks the field values on GetTestModuleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTestModuleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTestModuleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTestModuleReplyMultiError, or nil if none found.
func (m *GetTestModuleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTestModuleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestModule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTestModuleReplyValidationError{
					field:  "TestModule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTestModuleReplyValidationError{
					field:  "TestModule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestModule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTestModuleReplyValidationError{
				field:  "TestModule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTestModuleReplyMultiError(errors)
	}

	return nil
}

// GetTestModuleReplyMultiError is an error wrapping multiple validation errors
// returned by GetTestModuleReply.ValidateAll() if the designated constraints
// aren't met.
type GetTestModuleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTestModuleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTestModuleReplyMultiError) AllErrors() []error { return m }

// GetTestModuleReplyValidationError is the validation error returned by
// GetTestModuleReply.Validate if the designated constraints aren't met.
type GetTestModuleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTestModuleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTestModuleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTestModuleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTestModuleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTestModuleReplyValidationError) ErrorName() string {
	return "GetTestModuleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetTestModuleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTestModuleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTestModuleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTestModuleReplyValidationError{}

// Validate checks the field values on ListTestModuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTestModuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTestModuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTestModuleRequestMultiError, or nil if none found.
func (m *ListTestModuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTestModuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Parent

	// no validation rules for PageSize

	// no validation rules for PageToken

	if len(errors) > 0 {
		return ListTestModuleRequestMultiError(errors)
	}

	return nil
}

// ListTestModuleRequestMultiError is an error wrapping multiple validation
// errors returned by ListTestModuleRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTestModuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTestModuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTestModuleRequestMultiError) AllErrors() []error { return m }

// ListTestModuleRequestValidationError is the validation error returned by
// ListTestModuleRequest.Validate if the designated constraints aren't met.
type ListTestModuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTestModuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTestModuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTestModuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTestModuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTestModuleRequestValidationError) ErrorName() string {
	return "ListTestModuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTestModuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTestModuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTestModuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTestModuleRequestValidationError{}

// Validate checks the field values on ListTestModuleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTestModuleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTestModuleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTestModuleReplyMultiError, or nil if none found.
func (m *ListTestModuleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTestModuleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTestModuleReplyValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTestModuleReplyValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTestModuleReplyValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTestModuleReplyMultiError(errors)
	}

	return nil
}

// ListTestModuleReplyMultiError is an error wrapping multiple validation
// errors returned by ListTestModuleReply.ValidateAll() if the designated
// constraints aren't met.
type ListTestModuleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTestModuleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTestModuleReplyMultiError) AllErrors() []error { return m }

// ListTestModuleReplyValidationError is the validation error returned by
// ListTestModuleReply.Validate if the designated constraints aren't met.
type ListTestModuleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTestModuleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTestModuleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTestModuleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTestModuleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTestModuleReplyValidationError) ErrorName() string {
	return "ListTestModuleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListTestModuleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTestModuleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTestModuleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTestModuleReplyValidationError{}
